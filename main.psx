.psx
.create "main.bin", 0x80010000

j @main
nop

.include "math.psx"

@gpu_comm_addr equ 0x1f801814
@gpu_data_addr equ 0x1f801810

; write commands to the gpu_command port
@gpu_comm:
    sll     $a0, 24
    or      $a0, $a1
    sw      $a0, @gpu_comm_addr
    jr      $ra
    nop

; write commands to the @gpu_data port
@gpu_data:
    sll     $a0, 24
    or      $a0, $a1
    sw      $a0, @gpu_data_addr
    jr      $ra
    nop

; Init the gpu so we're ready to draw
@init_gpu:
    subiu   $sp, 4
    sw      $ra, 0($sp)

    ; Reset the GPU
    li      $a0, 0
    li      $a1, 0
    jal     @gpu_comm
    nop
    ; Set the horizontal start/end
    li      $a0, 6
    li      $a1, 0xc56
    sll     $a1, 12
    ori     $a1, 0x250
    jal     @gpu_comm
    nop
    ; Set the vertical start/end
    li      $a0, 7
    li      $a1, 0x100
    sll     $a1, 10
    ori     $a1, 0x10
    jal     @gpu_comm
    nop
    ; Set display mode
    li      $a0, 8
    li      $a1, 0x21 ; 0b0010_0001
    jal     @gpu_comm
    nop
    ; Set display offset
    li      $a0, 5
    li      $a1, 0x0
    jal     @gpu_comm
    nop
    ; Set draw mode
    li      $a0, 0xe1
    li      $a1, 0x200
    jal     @gpu_data
    nop
    ; Set draw area
    li      $a0, 0xe3
    li      $a1, 0x0
    jal     @gpu_data
    nop
    ; Set draw area
    li      $a0, 0xe4
    li      $a1, 0x3BD
    sll     $a1, 8
    ori     $a1, 0x3F
    jal     @gpu_data
    nop
    ; Set draw offset
    li      $a0, 0xe5
    li      $a1, 0b111111100010110000
    jal     @gpu_data
    nop
    ; Set DMA to CPU->GPU
    li      $a0, 4
    li      $a1, 0x2
    jal     @gpu_comm
    nop
    ; Enable the display
    li      $a0, 0x3
    li      $a1, 0x0
    jal     @gpu_comm
    nop

    ; Restore the return address, and return
    lw      $ra, 0($sp)
    addiu   $sp, 4
    jr      $ra
    nop

@clear_screen:
    li      $t0, 0x2000000
    sw      $t0, @gpu_data_addr
    sw      $zero, @gpu_data_addr
    li      $t0, 0x01ff03ff ; Screen bottom right coords
    sw      $t0, @gpu_data_addr
    jr      $ra
    nop

@main:
    subiu   $sp,$sp,4
    sw      $ra,0($sp)

    jal     @init_gpu
    nop

    ; Init GTe
    mfc0    $t0, $sr
    li      $t1, 0x40000000
    or      $t0, $t1
    mtc0    $t0, $sr

    li      $t0, 0x100
    ctc2    $t0, $24
    ctc2    $t0, $25

    ; Infinite loop
    li      $s0, 0x00000
@@main_loop:
    jal     @clear_screen
    nop

    ; Calculate sine & cos for rot mat
    move    $a0, $s0
    jal     math_sin
    move    $t0, $v0

    move    $a0, $s0
    jal     math_cos
    move    $t1, $v0

    ;; Fill out GTE rotation matrix
    move    $t3, $t0
    sub     $t3, $zero, $t3
    sll     $t3, 16
    or      $t3, $t1
    ctc2    $t3, $0
    sll     $t0, 16
    ctc2    $t0, $1
    li      $t2, 0x1000
    ctc2    $t1, $2
    ctc2    $zero, $3
    ctc2    $t2, $4

    ; Set H value
    li      $t0, 0x30
    ctc2    $t0, $26

    ; Set our translation vector
    li      $t0, 0x100
    ctc2    $t0, $7

    la      $s2, d_icosphere_mesh
    lw      $s1, d_icosphere_mesh
    addi    $s2, 4
@@for_each_tri:
    ;; Perform rotation of vertex 0
    ; Load vertex
    lw      $t1, 0($s2)
    lhu     $t2, 4($s2)
    addi    $s2, 8

    ; Pass to GTE
    mtc2    $t1, $0
    mtc2    $t2, $1

    ;; Perform rotation of vertex 1
    ; Load vertex
    lw      $t1, 0($s2)
    lhu     $t2, 4($s2)
    addi    $s2, 8

    ; Pass to GTE
    mtc2    $t1, $2
    mtc2    $t2, $3

    ;; Perform rotation of vertex 2
    ; Load vertex
    lw      $t1, 0($s2)
    lhu     $t2, 4($s2)
    addi    $s2, 8

    ; Pass to GTE
    mtc2    $t1, $4
    mtc2    $t2, $5

    ; Execute rotation
    cop2    0x280030

    ; Store result
    mfc2    $t0, $12
    mfc2    $t1, $13
    mfc2    $t2, $14
    sw      $t0, d_triange_v0
    sw      $t1, d_triange_v1
    sw      $t2, d_triange_v2

    ;; Draw a guroud shaded triangle
    li      $t0, 0x03000000
    sw      $t0, @gpu_comm_addr
    li      $t0, 0x30ff0000
    sw      $t0, @gpu_data_addr

    ; Vertex 0 pos
    lw      $t0, d_triange_v0
    sw      $t0, @gpu_data_addr

    ; Vertex 1 colour
    li      $t0, 0x0000ff00
    sw      $t0, @gpu_data_addr
    nop

    ; Vertex 1 pos
    lw      $t0, d_triange_v1
    sw      $t0, @gpu_data_addr
    nop

    ; Vertex 2 colour
    li      $t0, 0x000000ff
    sw      $t0, @gpu_data_addr

    ; Vertex 2 pos
    lw      $t0, d_triange_v2
    sw      $t0, @gpu_data_addr
    nop

    subi    $s1, 1
    bne     $s1, $zero, @@for_each_tri
    nop

    addi    $s0, 0x1
    andi    $s0, $s0, 0xff

    ; Start timer
    li      $t0, 0xfffff
    ; Spin for a bit
@@spin:
    subi    $t0, 1
    bne     $t0, $zero, @@spin
    nop

    ; Back to the start of the @main loop
    j       @@main_loop
    nop

    ; Restore and return
    lw      $ra,0($sp)
    addiu   $sp,$sp,4
    jr      $ra
    nop

.align 4
d_triange_v0:
.halfword 0, -50
.align 4
d_triange_v1:
.halfword 50, 50
.align 4
d_triange_v2:
.halfword -50, 50

.align 4
d_3d_triange_v0:
.halfword 0, -0x50, 0x0
.align 4
d_3d_triange_v1:
.halfword 0x50, 0x50, 0x0
.align 4
d_3d_triange_v2:
.halfword -0x50, 0x50, 0x0

.align 4
d_icosphere_mesh:
.incbin "raw_assets/meshes/icosphere.pxm"

.align 0x800
.close
